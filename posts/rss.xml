<?xml version="1.0"?>
<rss version="2.0">
  <channel>
    <title>Gettin' Rusty</title>
    <description>Gettin' Rusty</description>
    <link/>
    <pubDate>2014-01-22</pubDate>
    <item>
      <title>Destructuring in Rust</title>
      <link>/getting_rusty/posts/20140122_destructuring_in_rust</link>
      <pubDate>2014-01-22</pubDate>
      <description>&lt;p&gt;Here&amp;#39;s another piece I came along, while learning &lt;a href="http://rust-lang.org"&gt;Rust&lt;/a&gt;.
Pattern matching is one of the features I like most about modern / functional style languages, also one I sincerely enjoy in &lt;a href="http://rust-lang.org"&gt;Rust&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;It works in a lot of different scenarios, the most basic in a &lt;code&gt;let&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class="rust"&gt;let tuple = (1, 2);
let (a, b) = tuple; // =&amp;gt; a =  1; b = 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Also it works in a function&lt;/p&gt;

&lt;pre&gt;&lt;code class="rust"&gt;fn my_function((a, b) : (uint, uint)) -&amp;gt; uint {
  a + b
}

fn main() {
  let pair = (1, 2);
  my_function(pair); // =&amp;gt; 3
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It also can be used to destructure struct variants:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rust"&gt;#[feature(struct_variant)];

enum Fagazi {
  Fob { a: int },
  Foo { b: int, c: int }
}

#[test]
fn test_enum() {
  let foo = Foo { b: 1, c: 2 };

  match foo {
    Foo { b, c } if b &amp;gt; 2 =&amp;gt; assert!((b,c) == (1, 2)),
    Foo { b, c } =&amp;gt; assert!((b,c) == (1, 2)),
    _            =&amp;gt; fail!(&amp;quot;This will never happen, but the compiler doesn&amp;#39;t know&amp;quot;)
  };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You &lt;strong&gt;cannot&lt;/strong&gt; just destructure an enum with multiple variants using &lt;code&gt;let&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rust"&gt;let Foo { b, c } = foo; // ! Compiler error !
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You need to use a match instead of a simple let, because let can never fail (refutable pattern in local binding)
using the second condition in match, the compiler knows, all possible paths have been exhausted.&lt;/p&gt;

&lt;p&gt;One more cool feature of &lt;code&gt;match&lt;/code&gt; are guard clauses:&lt;/p&gt;

&lt;p&gt;fn test_enum() {
  let foo = Foo { b: 3, c: 2 };&lt;/p&gt;

&lt;p&gt;// need to use a match instead of a simple let, because let can never fail (refutable pattern in local binding)
  // using the second condition in match, the compiler knows, all possible paths have been exhausted
  match foo {
    Foo { b, c } if b &amp;lt;= 2 =&amp;gt; assert!(b &amp;lt;= 2 &amp;amp;&amp;amp; c == 2),
    Foo { b, c }          =&amp;gt; assert!((b, c) == (3, 2)),
    _                     =&amp;gt; fail!(&amp;quot;This will never happen&amp;quot;)
  };
}&lt;/p&gt;

&lt;p&gt;See the &lt;code&gt;if b &amp;lt;= 2&lt;/code&gt; in the first line?&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Ruby Stuff</title>
      <link>/getting_rusty/posts/20140108_ruby</link>
      <pubDate>2014-01-08</pubDate>
      <description>&lt;p&gt;Here are a few things you probably do in Ruby quite often:&lt;/p&gt;

&lt;h2 id="toc_0"&gt;Array&lt;/h2&gt;

&lt;h3 id="toc_1"&gt;Array#join&lt;/h3&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;s        = &amp;quot;A cat in the hat&amp;quot;
words    = s.split(&amp;quot; &amp;quot;)
combined = words.join(&amp;quot;:&amp;quot;) # =&amp;gt; &amp;quot;A:cat:in:the:hat&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class="rust"&gt;  let s              = ~&amp;quot;A cat in the hat&amp;quot;;
  let words: ~[&amp;amp;str] = s.words().collect();
  let combined       = words.connect(&amp;quot;:&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    <item>
      <title>Ruby p aka puts driven development in Rust</title>
      <link>/getting_rusty/posts/20140119_ruby_p_in_rust</link>
      <pubDate>2014-01-19</pubDate>
      <description>&lt;p&gt;Given the lack of a useful debugger in Ruby, we often refer to &lt;code&gt;p obj&lt;/code&gt; to print an object to the console in order to inspect its value.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;Foo = Struct.new(:bar)
foo = Foo.new(7)
p foo # =&amp;gt; #&amp;lt;struct Foo bar=7&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Actually you can do pretty much the same in Rust, too:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rust"&gt;struct Foo {
  bar: uint
}

fn main() {
  let foo = Foo { bar: 7u };
  p!(foo); // =&amp;gt; Foo{bar: 7u}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Actually Rust does not come from the factory with a &lt;code&gt;p!&lt;/code&gt; - a syntax extension or a macro, but we can write it ourselves:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rust"&gt;#[feature(macro_rules)];

macro_rules! p(
    ($ident:ident) =&amp;gt; (
        println!(&amp;quot;{:?}&amp;quot;, $ident);
    );
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notable here is the first line in the crate &lt;code&gt;#[feature(macro_rules)];&lt;/code&gt; is required to enable macro rules, as those are as of today considered to be unstable. Do not forget the semicolon at the end, otherwise it won&amp;#39;t work!&lt;/p&gt;

&lt;p&gt;For more on macros see the &lt;a href="http://static.rust-lang.org/doc/master/guide-macros.html"&gt;Macro tutorial&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>ToStr</title>
      <link>/getting_rusty/posts/20140108_to_str</link>
      <pubDate>2014-01-08</pubDate>
      <description>How to get (almost) any type to support `to_str`</description>
    </item>
  </channel>
</rss>
