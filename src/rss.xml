<?xml version="1.0"?>
<rss version="2.0">
  <channel>
    <title>Getting Rusty</title>
    <description>Getting Rusty</description>
    <link/>
    <pubDate>2014-04-17</pubDate>
    <item>
      <title>Strings</title>
      <link>/getting_rusty/src/strings.rs</link>
      <description>#[test]
fn test_compare_fails(){
  let hobbit_name = ~"Bilbo Baggins";
  // if hobbit_name == "Bilbo Baggins" {}; // -&gt; error

  if "Bilbo Baggins" == hobbit_name {};
  if hobbit_name == "Bilbo Baggins".to_owned() {};
  if hobbit_name.as_slice() == "Bilbo Baggins" {};
}

fn compare_ci(x: &amp;str, y: &amp;str) -&gt; bool {
  let mut it = x.chars().zip(y.chars());
  it.all(|(x,y)|
    unsafe {
      x.to_ascii_nocheck().to_lower() == y.to_ascii_nocheck().to_lower()
    }
  )
}

#[test]
fn test_compare_case_insensitive(){
  let x = ~"Bilbo B&#xE4;ggins";
  let y = ~"bILbo b&#xE4;Ggins";

  assert_eq!(compare_ci(x, y), true);
}

#[test]
fn test_ci(){
  let x = "Bilbo";
  let y = "bIlbo";
  // assert_eq!(x.to_lower(), y.to_lower());
}

#[test]
fn test_from_str(){
  let f: f32 = from_str("1.2").unwrap(); // 1.2f32
  assert_eq!(f, 1.2f32);

  let oi: Option&lt;uint&gt; = from_str("1");
  assert_eq!(oi, Some(1u));

  let oi: Option&lt;uint&gt; = from_str("x");
  assert_eq!(oi, None);

  let i: uint = from_str("2").unwrap();
  assert_eq!(i, 2);

  // let i: uint = from_str("x").unwrap();
  // assert_eq!(i, 0);

  let i: uint = match from_str("3") {
    Some(value) =&gt; value,
    None        =&gt; fail!("oops, expected a number")
  };
  assert_eq!(i, 3);

  let i: uint = from_str("4").unwrap_or(0u);
  assert_eq!(i, 4);


  let i = from_str::&lt;uint&gt;("5").unwrap();
  assert_eq!(i, 5);
}

#[test]
fn test_empty(){
  assert!((~"").is_empty());
  assert!((&amp;"").is_empty());
  assert!(!"B&#xE4;r".is_empty());
}

#[test]
fn test_length(){
  let s = ~"B&#xE4;r";
  assert_eq!(s.char_len(), 3);
}


#[test]
fn test_concat(){
  let x = ~"abc";
  let y = ~"def";

  let z = x + y;
  assert_eq!(~"abcdef", z)

  let a = ~"foo";
  let b = ~"bar";
  let c = a.append(b);
  assert_eq!(~"foobar", c);
}

#[test]
fn test_mutate(){
  let mut foo = ~"foo";
  foo.push_str("bar");
  assert_eq!(~"foobar", foo);
}

#[test]
fn test_replace(){
  let bilbo = ~"Bilbo Baggins";
  let frodo = bilbo.replace("Bilbo", "Frodo");
  assert_eq!(~"Frodo Baggins", frodo);

  let samwise = bilbo.replace("Frodo", "Samwise");
  assert_eq!(samwise, bilbo);
}

#[test]
fn test_start_end_with(){
  let bilbo = ~"Bilbo Baggins";
  assert_eq!(bilbo.starts_with("Bilbo"), true);
  assert_eq!(bilbo.starts_with("bilbo"), false);
  assert_eq!(bilbo.ends_with("Baggins"), true);
  assert_eq!(bilbo.ends_with("baggins"), false);
}

#[test]
fn test_owned_borrowed() {
let mut owned: ~str    = ~"foobar";
let mut borrowed: &amp;str = &amp;"foobaz";

assert_eq!(owned, ~"foobar");
assert_eq!(borrowed, "foobaz");

owned    = borrowed.to_owned();
assert_eq!(owned, ~"foobaz");

borrowed = owned.as_slice();
assert_eq!(borrowed, &amp;"foobaz");
}

// reference shit

struct Foo&lt;'a&gt; {
  name: &amp;'a str
}

impl&lt;'a&gt; Foo&lt;'a&gt; {
  fn name(&amp;'a mut self, s: &amp;'a str) -&gt; &amp;'a mut Foo&lt;'a&gt; {
    self.name = s;
    self
  }
}

#[test]
fn test_in_struct(){
  let s = ~"foo";
  let mut foo = Foo { name: s.as_slice() };

  assert_eq!(foo.name, "foo");

  let foo = foo.name("bar");
  assert_eq!(foo.name, "bar");
}

#[test]
fn Converting_to_String(){
  let i = 1i32;
  assert_eq!(i.to_str(), ~"1");
  // let j = 2.to_str::&lt;i8&gt;();
  // assert_eq!(j, ~"2");
}

struct LowerChars&lt;'a&gt; {
  chars: std::str::Chars&lt;'a&gt;
}

fn lower&lt;'a&gt;(s: &amp;'a str) -&gt; LowerChars&lt;'a&gt; {
  LowerChars { chars: s.chars() }
}

impl&lt;'a&gt; Iterator&lt;char&gt; for LowerChars&lt;'a&gt; {
  fn next(&amp;mut self) -&gt; Option&lt;char&gt; {
    self.chars.next().map(|c| c.to_lowercase())
  }
}

#[test]
fn test_to_uppercase(){
  let sl = "foob&#xE4;r";
  let su = "FOOB&#xC4;R";

  let mut z = lower(sl).zip(lower(su));
  assert!(z.all(|(x, y)| x == y ));

  // let ss = "foob&#xE4;r".chars().map(|c| c.to_uppercase()).collect::&lt;~str&gt;();
  // assert_eq!(ss.as_slice(), su);
}
</description>
    </item>
  </channel>
</rss>
